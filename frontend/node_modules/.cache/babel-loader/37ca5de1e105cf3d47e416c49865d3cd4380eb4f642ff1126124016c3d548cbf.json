{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hp\\\\Downloads\\\\package (8)\\\\frontend\\\\src\\\\contexts\\\\ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  const context = useContext(ChatContext);\n  if (!context) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};\n_s(useChat, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user,\n    token,\n    isAuthenticated\n  } = useAuth();\n  const [chats, setChats] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isTyping, setIsTyping] = useState(false);\n  const [loading, setLoading] = useState(false);\n  // No real-time socket connection: chat operates over HTTP endpoints only.\n\n  // Load user's chats\n  const loadChats = async () => {\n    try {\n      const response = await axios.get('/ai/chats');\n      if (response.data.success) {\n        setChats(response.data.chats);\n      }\n    } catch (error) {\n      console.error('Failed to load chats:', error);\n      toast.error('Failed to load chat history');\n    }\n  };\n\n  // Load messages for a specific chat\n  const loadMessages = async chatId => {\n    try {\n      setLoading(true);\n      const response = await axios.get(`/students/chats?chat_id=${chatId}`);\n      if (response.data.success) {\n        setMessages(response.data.messages || []);\n        setCurrentChat(response.data.chat);\n      }\n    } catch (error) {\n      console.error('Failed to load messages:', error);\n      toast.error('Failed to load messages');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Create a new chat\n  const createChat = async (title = 'New Chat') => {\n    try {\n      const response = await axios.post('/ai/chats', {\n        title\n      });\n      if (response.data.success) {\n        const newChat = {\n          id: response.data.chat_id,\n          title: title,\n          created_at: new Date().toISOString(),\n          last_activity: new Date().toISOString(),\n          message_count: 0,\n          total_tokens: 0\n        };\n        setChats(prev => [newChat, ...prev]);\n        return newChat;\n      }\n    } catch (error) {\n      console.error('Failed to create chat:', error);\n      toast.error('Failed to create new chat');\n      return null;\n    }\n  };\n\n  // Send message via HTTP (fallback) or WebSocket\n  const sendMessage = async (message, chatId = null) => {\n    try {\n      // If no chatId provided, create a new chat\n      let targetChatId = chatId;\n      if (!targetChatId) {\n        const newChat = await createChat();\n        if (!newChat) return false;\n        targetChatId = newChat.id;\n        setCurrentChat(newChat);\n      }\n\n      // Use HTTP API to send message\n      {\n        // Fallback to HTTP\n        const response = await axios.post('/ai/chat', {\n          message: message,\n          chat_id: targetChatId\n        });\n        if (response.data.success) {\n          // Add messages to state manually since no WebSocket\n          const userMessage = {\n            sender: 'user',\n            text: message,\n            timestamp: new Date().toISOString()\n          };\n          const aiMessage = {\n            sender: 'ai',\n            text: response.data.message,\n            message_id: response.data.message_id,\n            timestamp: new Date().toISOString(),\n            tutor_suggestions: response.data.tutor_suggestions || []\n          };\n          setMessages(prev => [...prev, userMessage, aiMessage]);\n\n          // Update chat in list\n          setChats(prev => prev.map(chat => chat.id === targetChatId ? {\n            ...chat,\n            last_activity: new Date().toISOString(),\n            message_count: chat.message_count + 2\n          } : chat));\n          return true;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      toast.error('Failed to send message');\n      return false;\n    }\n  };\n\n  // Join a chat room (WebSocket)\n  const joinChat = chatId => {\n    // No-op: WebSocket removed\n  };\n\n  // Leave a chat room (WebSocket)\n  const leaveChat = chatId => {\n    // No-op: WebSocket removed\n  };\n\n  // Start typing indicator\n  const startTyping = chatId => {\n    // No-op: WebSocket removed\n  };\n\n  // Stop typing indicator\n  const stopTyping = chatId => {\n    // No-op: WebSocket removed\n  };\n\n  // Rate an AI message\n  const rateMessage = async (messageId, rating, feedback = null) => {\n    try {\n      const response = await axios.post('/ai/rate', {\n        message_id: messageId,\n        rating: rating,\n        feedback: feedback\n      });\n      if (response.data.success) {\n        toast.success('Rating submitted successfully');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to rate message:', error);\n      toast.error('Failed to submit rating');\n      return false;\n    }\n  };\n\n  // Delete a chat\n  const deleteChat = async chatId => {\n    try {\n      const response = await axios.delete(`/students/chats/${chatId}`);\n      if (response.data.success) {\n        setChats(prev => prev.filter(chat => chat.id !== chatId));\n        if ((currentChat === null || currentChat === void 0 ? void 0 : currentChat.id) === chatId) {\n          setCurrentChat(null);\n          setMessages([]);\n        }\n        toast.success('Chat deleted successfully');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to delete chat:', error);\n      toast.error('Failed to delete chat');\n      return false;\n    }\n  };\n\n  // Update chat title\n  const updateChatTitle = async (chatId, title) => {\n    try {\n      const response = await axios.put(`/students/chats/${chatId}/title`, {\n        title\n      });\n      if (response.data.success) {\n        setChats(prev => prev.map(chat => chat.id === chatId ? {\n          ...chat,\n          title\n        } : chat));\n        if ((currentChat === null || currentChat === void 0 ? void 0 : currentChat.id) === chatId) {\n          setCurrentChat(prev => ({\n            ...prev,\n            title\n          }));\n        }\n        toast.success('Chat title updated');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to update chat title:', error);\n      toast.error('Failed to update title');\n      return false;\n    }\n  };\n  const value = {\n    // State\n    chats,\n    currentChat,\n    messages,\n    isTyping,\n    loading,\n    // Actions\n    loadChats,\n    loadMessages,\n    createChat,\n    sendMessage,\n    joinChat,\n    leaveChat,\n    startTyping,\n    stopTyping,\n    rateMessage,\n    deleteChat,\n    updateChatTitle,\n    // Setters\n    setCurrentChat,\n    setMessages\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 241,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"YfZfAhd2fvf2EQrRWcdMcO7lUXg=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","axios","toast","useAuth","jsxDEV","_jsxDEV","ChatContext","useChat","_s","context","Error","ChatProvider","children","_s2","user","token","isAuthenticated","chats","setChats","currentChat","setCurrentChat","messages","setMessages","isTyping","setIsTyping","loading","setLoading","loadChats","response","get","data","success","error","console","loadMessages","chatId","chat","createChat","title","post","newChat","id","chat_id","created_at","Date","toISOString","last_activity","message_count","total_tokens","prev","sendMessage","message","targetChatId","userMessage","sender","text","timestamp","aiMessage","message_id","tutor_suggestions","map","joinChat","leaveChat","startTyping","stopTyping","rateMessage","messageId","rating","feedback","deleteChat","delete","filter","updateChatTitle","put","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/hp/Downloads/package (8)/frontend/src/contexts/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\nimport { useAuth } from './AuthContext';\n\nconst ChatContext = createContext();\n\nexport const useChat = () => {\n  const context = useContext(ChatContext);\n  if (!context) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};\n\nexport const ChatProvider = ({ children }) => {\n  const { user, token, isAuthenticated } = useAuth();\n  const [chats, setChats] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isTyping, setIsTyping] = useState(false);\n  const [loading, setLoading] = useState(false);\n  // No real-time socket connection: chat operates over HTTP endpoints only.\n\n  // Load user's chats\n  const loadChats = async () => {\n    try {\n      const response = await axios.get('/ai/chats');\n      if (response.data.success) {\n        setChats(response.data.chats);\n      }\n    } catch (error) {\n      console.error('Failed to load chats:', error);\n      toast.error('Failed to load chat history');\n    }\n  };\n\n  // Load messages for a specific chat\n  const loadMessages = async (chatId) => {\n    try {\n      setLoading(true);\n      const response = await axios.get(`/students/chats?chat_id=${chatId}`);\n      if (response.data.success) {\n        setMessages(response.data.messages || []);\n        setCurrentChat(response.data.chat);\n      }\n    } catch (error) {\n      console.error('Failed to load messages:', error);\n      toast.error('Failed to load messages');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Create a new chat\n  const createChat = async (title = 'New Chat') => {\n    try {\n      const response = await axios.post('/ai/chats', { title });\n      if (response.data.success) {\n        const newChat = {\n          id: response.data.chat_id,\n          title: title,\n          created_at: new Date().toISOString(),\n          last_activity: new Date().toISOString(),\n          message_count: 0,\n          total_tokens: 0\n        };\n        setChats(prev => [newChat, ...prev]);\n        return newChat;\n      }\n    } catch (error) {\n      console.error('Failed to create chat:', error);\n      toast.error('Failed to create new chat');\n      return null;\n    }\n  };\n\n  // Send message via HTTP (fallback) or WebSocket\n  const sendMessage = async (message, chatId = null) => {\n    try {\n      // If no chatId provided, create a new chat\n      let targetChatId = chatId;\n      if (!targetChatId) {\n        const newChat = await createChat();\n        if (!newChat) return false;\n        targetChatId = newChat.id;\n        setCurrentChat(newChat);\n      }\n\n      // Use HTTP API to send message\n      {\n        // Fallback to HTTP\n        const response = await axios.post('/ai/chat', {\n          message: message,\n          chat_id: targetChatId\n        });\n\n        if (response.data.success) {\n          // Add messages to state manually since no WebSocket\n          const userMessage = {\n            sender: 'user',\n            text: message,\n            timestamp: new Date().toISOString()\n          };\n\n          const aiMessage = {\n            sender: 'ai',\n            text: response.data.message,\n            message_id: response.data.message_id,\n            timestamp: new Date().toISOString(),\n            tutor_suggestions: response.data.tutor_suggestions || []\n          };\n\n          setMessages(prev => [...prev, userMessage, aiMessage]);\n\n          // Update chat in list\n          setChats(prev => prev.map(chat =>\n            chat.id === targetChatId\n              ? { ...chat, last_activity: new Date().toISOString(), message_count: chat.message_count + 2 }\n              : chat\n          ));\n\n          return true;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      toast.error('Failed to send message');\n      return false;\n    }\n  };\n\n  // Join a chat room (WebSocket)\n  const joinChat = (chatId) => {\n    // No-op: WebSocket removed\n  };\n\n  // Leave a chat room (WebSocket)\n  const leaveChat = (chatId) => {\n    // No-op: WebSocket removed\n  };\n\n  // Start typing indicator\n  const startTyping = (chatId) => {\n    // No-op: WebSocket removed\n  };\n\n  // Stop typing indicator\n  const stopTyping = (chatId) => {\n    // No-op: WebSocket removed\n  };\n\n  // Rate an AI message\n  const rateMessage = async (messageId, rating, feedback = null) => {\n    try {\n      const response = await axios.post('/ai/rate', {\n        message_id: messageId,\n        rating: rating,\n        feedback: feedback\n      });\n\n      if (response.data.success) {\n        toast.success('Rating submitted successfully');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to rate message:', error);\n      toast.error('Failed to submit rating');\n      return false;\n    }\n  };\n\n  // Delete a chat\n  const deleteChat = async (chatId) => {\n    try {\n      const response = await axios.delete(`/students/chats/${chatId}`);\n      if (response.data.success) {\n        setChats(prev => prev.filter(chat => chat.id !== chatId));\n        if (currentChat?.id === chatId) {\n          setCurrentChat(null);\n          setMessages([]);\n        }\n        toast.success('Chat deleted successfully');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to delete chat:', error);\n      toast.error('Failed to delete chat');\n      return false;\n    }\n  };\n\n  // Update chat title\n  const updateChatTitle = async (chatId, title) => {\n    try {\n      const response = await axios.put(`/students/chats/${chatId}/title`, { title });\n      if (response.data.success) {\n        setChats(prev => prev.map(chat =>\n          chat.id === chatId ? { ...chat, title } : chat\n        ));\n        if (currentChat?.id === chatId) {\n          setCurrentChat(prev => ({ ...prev, title }));\n        }\n        toast.success('Chat title updated');\n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to update chat title:', error);\n      toast.error('Failed to update title');\n      return false;\n    }\n  };\n\n  const value = {\n    // State\n    chats,\n    currentChat,\n    messages,\n    isTyping,\n    loading,\n\n    // Actions\n    loadChats,\n    loadMessages,\n    createChat,\n    sendMessage,\n    joinChat,\n    leaveChat,\n    startTyping,\n    stopTyping,\n    rateMessage,\n    deleteChat,\n    updateChatTitle,\n\n    // Setters\n    setCurrentChat,\n    setMessages\n  };\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}